Problem 1. 다익스트라 알고리즘 기본문항. 백준 1753
노드, 간선 수 받고 시작 노드 받고 각 연결노드 및 dist 받아옴. 최단거리 구하기

sys랑 heapq import.
input sys.stdin.readline
INF 설정 int(1e9)

노드랑 간선 개수 받아오고, start 받아오기
인접 리스트로 그래프 표현(그래프의 각 index마다 list 형태로 설정)

각 연결노드랑 dist 받은거 graph에 추가하기. 

최단거리 테이블 만들기(요소 n+1개)

Dijkstra define해서 start만 인자로 받음.
q라는 우선순위 큐 사용. (거리,노드) 형태의 튜플로 시작 노드 정보 힙에 추가
시작노드 거리 0으로 초기화

큐가 빌 때까지
하나 꺼내서 꺼낸 노드 거리가 이미 쌓아둔 최단 거리 테이블보다 크면 그냥 continue(pass)

이제 graph[now]에 대해 하나씩 뽑아오면서 cost값 만들고 이미 쌓은 테이블보다 작으면 변경 후 큐에 추가(왜냐면 이제 그 노드부터 갈거니까.)

그럼 끝. 이제 그냥 Dijkstra 실행시키고, 각 거리 출력하면 됨.


Problem 2. 다익스트라 미로(좌표형) 문항. 백준 4485
입력이 0일 때까지 정사각행렬 크기 + 값들 받아옴. 받아서 최저값으로 탈출하도록 설계하기.

우선 dx dy 정의해주고 기본 정의들 해줌. 

원래 다익스트라는 노드와 연결된 노드 중 최저 cost를 찾는 것이 목적이었다면, 얘는 상하좌우가 테두리를 제외하고는 모두 연결되어 있으므로 BFS형태로 최저를 찾아나가야 한다. 그 과정에서 다익스트라가 사용되지는 않을 것 같은데... 그냥 heapq 형태로만 쓰는건가?
-> 그런듯. bfs처럼 탐색하되, 탐색 결과 nx ny 위치를 다 queue에 넣고(원래 cost보다 작다면), 그 다음 queue pop에서 그 중 최저값부터 나오도록 할 때 사용하네.(최저탐색 큐 형태)

전체 흐름은... 0,0에서 시작하여 dx dy만큼 이동한 위치가 올바르면, 그 위치까지의 cost가 최저값이라면 그 위치로 이동. 반복.


Problem 3. 매 노드마다 거리 계산법이 달라지는 다익스트라. 달빛 여우 : 백준 16118

달빛 여우와 늑대가 등장하는 문항. 연결된 노드를 최단거리를 따라 이동하며 각 노드에 도달하는 문항. 여우만 보면 기본적인 다익스트라 문항이었다.
그래서 여우와 늑대를 list명만 바꿔서 dist와 heap queue를 만들어 준 후 여우 작성을 마쳤다.
그리고 나서 늑대 코드를 짜기 시작했는데, 기본 베이스를 여우 코드와 동일하게 잡고 필요한 부분만 수정하자는 판단에서 뼈대를 만들었다.
처음에는 단순히 temp 변수를 만들어서 매 진행마다 toggle시키는 방향으로 진행했는데, 이는 매번 바로 이전에 진행한 노드가 이번 시작 노드라는 보장이 없었다.
따라서 queue에 push할 때 요소를 하나 더 늘려서 temp를 state의 역할을 하도록 넣어주었다.
그래도 올바른 값이 안 나오는 부분이 있길래, 추가로 생각한 것이 dist_wolf 자체를 state에 따라 2개로 나눠서 표현하는 것.

각 노드마다 최소값을 하나로 고정해야 한다는 관념을 버리고 접근하여 문제를 해결할 수 있었다.
이 때 dist_wolf[1][1] = INF로 설정하여 첫 노드에서는 상태가 무조건 0으로 고정되도록 설계하였다. 이 부분에서 문제가 생길지는 잘 모르겠다...만 백준 상에서 제출한 결과는 맞았습니다!!! 였으므로... 만족한다.💖
(추가 : 처음부터 각 노드 사이 거리를 2배로 저장하면 float 사용 없이 늑대 거리를 처리 가능하여 float와의 크기 비교 문제를 없앨 수 있다..!)
